/**
 * CSRF Token Generation and Validation
 *
 * Provides cryptographically secure CSRF protection using the Double Submit Cookie pattern.
 * - Tokens are generated using crypto.randomBytes for cryptographic randomness
 * - Validation uses HMAC to prevent token forgery
 * - Minimum token length of 32 bytes for security
 *
 * Security guarantees:
 * - Tokens cannot be guessed (cryptographically random)
 * - Tokens cannot be forged (HMAC signed with secret)
 * - Timing-safe comparison prevents timing attacks
 */

import crypto from 'crypto';

// CSRF secret key for HMAC signing
// In production, this should be loaded from environment variable
const CSRF_SECRET = process.env.CSRF_SECRET || 'default-csrf-secret-change-in-production';

// Token length in bytes (32 bytes = 256 bits)
const TOKEN_LENGTH = 32;

/**
 * Generate a cryptographically secure CSRF token
 *
 * Creates a random token and signs it with HMAC to prevent forgery.
 * The token is a combination of random bytes and an HMAC signature.
 *
 * @returns {string} Base64-encoded CSRF token
 *
 * @example
 * const token = generateCsrfToken();
 * // Returns: "AbCd1234...==|HmAc5678...=="
 */
export function generateCsrfToken() {
  // Generate cryptographically secure random bytes
  const randomBytes = crypto.randomBytes(TOKEN_LENGTH);

  // Create HMAC signature of the random bytes
  const hmac = crypto.createHmac('sha256', CSRF_SECRET);
  hmac.update(randomBytes);
  const signature = hmac.digest('base64');

  // Combine random bytes and signature
  const tokenValue = randomBytes.toString('base64');
  const token = `${tokenValue}|${signature}`;

  return token;
}

/**
 * Validate a CSRF token
 *
 * Verifies that the token was generated by our system and hasn't been tampered with.
 * Uses timing-safe comparison to prevent timing attacks.
 *
 * @param {string} token - The CSRF token to validate
 * @returns {boolean} True if token is valid, false otherwise
 *
 * @example
 * const isValid = validateCsrfToken(token);
 * if (!isValid) {
 *   throw new Error('Invalid CSRF token');
 * }
 */
export function validateCsrfToken(token) {
  if (!token || typeof token !== 'string') {
    return false;
  }

  // Split token into value and signature
  const parts = token.split('|');
  if (parts.length !== 2) {
    return false;
  }

  const [tokenValue, providedSignature] = parts;

  try {
    // Recreate HMAC signature from token value
    const randomBytes = Buffer.from(tokenValue, 'base64');
    const hmac = crypto.createHmac('sha256', CSRF_SECRET);
    hmac.update(randomBytes);
    const expectedSignature = hmac.digest('base64');

    // Use timing-safe comparison to prevent timing attacks
    return crypto.timingSafeEqual(
      Buffer.from(providedSignature),
      Buffer.from(expectedSignature)
    );
  } catch (error) {
    // Invalid base64 or buffer comparison failed
    return false;
  }
}

/**
 * Get the CSRF secret (for testing/debugging purposes only)
 * @private
 * @returns {string}
 */
export function _getCsrfSecret() {
  return CSRF_SECRET;
}
